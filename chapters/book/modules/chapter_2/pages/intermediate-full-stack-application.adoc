[id="intermediate-full-stack-application"]

= Starknet Homepage

https://github.com/dbejarano820/starknet_homepage[Starknet Homepage] is a decentralized web application built on the Starknet blockchain. The main idea behind this project is to create a virtual space where users can own and customize small pieces of a 100x100 grid called "Starknet Homepage". Each block represents a 10x10 pixel area, and users can purchase these blocks by minting non-fungible tokens (NFTs) that they can customize with images and other details.
The live app interacting with testnet can be viewed https://starknet-homepage-kappa.vercel.app/[here].

image::starknet-homepage.jpg[starknet-homepage, width=640,height=480]

The infamous Million Dollar Homepage adapted and brought to Starknet.
This project was born at the Starknet Summit 2023 Hacker House in Palo Alto, California. This page will be a walkthrough of how the project was built leveraging existing tools in the ecosystem at the time.

Tools used:

* https://github.com/apibara/starknet-react[Starknet-react]
* https://github.com/0xs34n/starknet.js[Starknet.js]
* https://github.com/OpenZeppelin/cairo-contracts[OpenZeppelin Cairo Contracts]
* https://mui.com/material-ui/[MaterialUI]


== Initial Setup

The Starknet-react app provides a command to kickstart a starknet app, providing the basic structure for a NextJS application to begin working on.

[source,shell]
----
npx create-starknet
----

The `StarknetConfig` component apart from accepting a connectors prop, allowing the definition of wallet connection options available to the user, it also accepts a default provider to determine which network the application tries connecting to.

[source,typescript]
----
  const connectors = [
    new InjectedConnector({ options: { id: "braavos" } }),
    new InjectedConnector({ options: { id: "argentX" } }),
  ];

  const provider = new Provider({
    sequencer: { network: constants.NetworkName.SN_GOERLI },
  });

  return (
    <StarknetConfig
      autoConnect
      defaultProvider={provider}
      connectors={connectors}
    >
      <CacheProvider value={emotionCache}>
        <ThemeProvider theme={theme}>
          <Component {...pageProps} />
        </ThemeProvider>
      </CacheProvider>
    </StarknetConfig>
  );
----

The CacheProvider and ThemeProvider are components for integrating MaterialUI and NextJS in the most optimal manner. Further reading on the 
setup for these specific components is found https://blog.logrocket.com/getting-started-with-mui-and-next-js/[here].         

== Main Functionality

The main functionality of the Starknet Homepage lies in the ability to select a 4 sided area on the matrix with the desired 10x10 cells, and mint a token with those cells in mind. The smart contract is in charge of validating if 
the selected cells are available for minting or not. If you own tokens of the Starknet Homepage, a dropdown with them will be available in order to modify the content of the token. This includes the image and link of the area of the grid.

At a high level, the app has the following requirements:

* Connect a Wallet
* Grid to visualize the existing tokens
* Ability to select an area of cells
* Multicall for approving and minting tokens
* Dropdown to visualize owned tokens
* An on-chain representation of the 1 million pixel grid

One important consideration for this application is the string limitation in cairo contracts. 
In order to store links with an arbitrary size, we must store this value as an array of felt252's. The following logic in the contract allows for this.

[source, rust]
----
impl StoreFelt252Array of Store<Array<felt252>> {
    fn read(address_domain: u32, base: StorageBaseAddress) -> SyscallResult<Array<felt252>> {
        StoreFelt252Array::read_at_offset(address_domain, base, 0)
    }

    fn write(
        address_domain: u32, base: StorageBaseAddress, value: Array<felt252>
    ) -> SyscallResult<()> {
        StoreFelt252Array::write_at_offset(address_domain, base, 0, value)
    }

    fn read_at_offset(
        address_domain: u32, base: StorageBaseAddress, mut offset: u8
    ) -> SyscallResult<Array<felt252>> {
        let mut arr: Array<felt252> = ArrayTrait::new();

        // Read the stored array's length. If the length is superior to 255, the read will fail.
        let len: u8 = Store::<u8>::read_at_offset(address_domain, base, offset)
            .expect('Storage Span too large');
        offset += 1;

        // Sequentially read all stored elements and append them to the array.
        let exit = len + offset;
        loop {
            if offset >= exit {
                break;
            }

            let value = Store::<felt252>::read_at_offset(address_domain, base, offset).unwrap();
            arr.append(value);
            offset += Store::<felt252>::size();
        };

        Result::Ok(arr)
    }

    fn write_at_offset(
        address_domain: u32, base: StorageBaseAddress, mut offset: u8, mut value: Array<felt252>
    ) -> SyscallResult<()> {
        // // Store the length of the array in the first storage slot. 255 of elements is max
        let len: u8 = value.len().try_into().expect('Storage - Span too large');

        Store::<u8>::write_at_offset(address_domain, base, offset, len);

        offset += 1;

        // Store the array elements sequentially
        loop {
            match value.pop_front() {
                Option::Some(element) => {
                    Store::<felt252>::write_at_offset(address_domain, base, offset, element);

                    offset += Store::<felt252>::size();
                },
                Option::None => {
                    break Result::Ok(());
                }
            };
        }
    }

    fn size() -> u8 {
        255 / Store::<felt252>::size()
    }
}
----

This allows us to store links in the contract state in the following manner.

[source, rust]
----
struct Cell {
    token_id: u256,
    xpos: u8,
    ypos: u8,
    width: u8,
    height: u8,
    img: Array<felt252>,
    link: Array<felt252>,
}
----

The OpenZeppelin Cairo Contracts library is an incredibly useful tool that expidited the development of the ERC721 contract for Starknet Homepage, contract which can be observed https://github.com/dbejarano820/starknet_homepage/blob/main/cairo_contracts/src/ERC721.cairo[here].
Once the library is installed, a general example of how to utilize it is this following:

[source, typescript]
----
#[starknet::contract]
mod MyToken {
    use starknet::ContractAddress;
    use openzeppelin::token::erc20::ERC20;

    #[storage]
    struct Storage {}

    #[constructor]
    fn constructor(
        ref self: ContractState,
        initial_supply: u256,
        recipient: ContractAddress
    ) {
        let name = 'MyToken';
        let symbol = 'MTK';

        let mut unsafe_state = ERC20::unsafe_new_contract_state();
        ERC20::InternalImpl::initializer(ref unsafe_state, name, symbol);
        ERC20::InternalImpl::_mint(ref unsafe_state, recipient, initial_supply);
    }

    #[external(v0)]
    fn name(self: @ContractState) -> felt252 {
        let unsafe_state = ERC20::unsafe_new_contract_state();
        ERC20::ERC20Impl::name(@unsafe_state)
    }

    ...
}
----

=== Component Logic
==== Grid
The Grid component is a matrix of 100x100 cells (100 pixels each), mirroring the data structure in the smart contract. In order
to display the existing tokens minted on the Homepage, the app uses a React Hook from starknet-react in order to call the `getAllTokens` external function of the contract.

[source, rust]
----
  const [allNfts, setAllNfts] = useState<any[]>([]);

  const { data, isLoading } = useContractRead({
    address: STARKNET_HOMEPAGE_ERC721_ADDRESS,
    functionName: "getAllTokens",
    abi: starknetHomepageABI,
    args: [],
  });

  useEffect(() => {
    if (!isLoading) {
      const arr = data?.map((nft) => {
        return deserializeTokenObject(nft);
      });
      setAllNfts(arr || []);
    }
  }, [data, isLoading]);
----

The deserialization logic is in charge of ensuring the data from the starknet contract is transformed correctly in order to be utilized in the frontend.
This includes decoding the array of felt252's into long strings.

[source, typescript]
----
import { shortString, num } from "starknet";

const deserializeFeltArray = (arr: any) => {
  return arr
    .map((img: bigint) => {
      return shortString.decodeShortString(num.toHex(img));
    })
    .join("");
};

...
    img: deserializeFeltArray(tokenObject.img),
    link: deserializeFeltArray(tokenObject.link),
...
----

This Grid component is also in charge of the logic for selecting an area of cells and making a transaction in order to mint a token with them.
Once the area is selected, a Modal will appear with the mint information and additional inputs which are part of the call data. The actual multicall will be discussed later on.

image::starknet-homepage-select.jpg[starknet-homepage-select, width=640,height=480]

==== Modals
Modals are very useful for displaying different functionalities within the app. functionalities such as wallet connection, mint action and token editing.

image::starknet-homepage-wallets.jpg[starknet-homepage-wallets, width=640,height=480]

Typically, a best practice is to call the react hook for shared information at a higher level and maintain components such as the WalletBar as "dumb" as possible.

[source, typescript]
----
const { address } = useAccount();

return (
    ...
    <WalletBar account={address} />
    ...
)
----

[source, typescript]
----
function WalletConnected({ address }: { address: string }) {
  const { disconnect } = useConnectors();
  const { chain } = useNetwork();
  const shortenedAddress = useMemo(() => {
    if (!address) return "";
    return `${address.slice(0, 6)}...${address.slice(-4)}`;
  }, [address]);

  return (
    <StyledBox>
      <StyledButton color="inherit" onClick={disconnect}>
        {shortenedAddress}
      </StyledButton>
      <span>&nbsp;Connected to {chain && chain.name}</span>
    </StyledBox>
  );
}

function ConnectWallet() {
  const { connectors, connect } = useConnectors();
  const [open, setOpen] = useState(false);
  const theme = useTheme();

  const handleClickOpen = () => {
    setOpen(true);
  };

  const handleClose = () => {
    setOpen(false);
  };

  return (
    <StyledBox>
      <StyledButton color="inherit" onClick={handleClickOpen}>
        Connect Wallet
      </StyledButton>
      <Dialog open={open} onClose={handleClose}>
        <DialogTitle>Connect to a wallet</DialogTitle>
        <DialogContent>
          <DialogContentText>
            <Grid container direction="column" alignItems="flex-start" gap={1}>
              {connectors.map((connector) => (
                <ConnectWalletButton
                  key={connector.id}
                  onClick={() => {
                    connect(connector);
                    handleClose();
                  }}
                  sx={{ margin: theme.spacing(1) }}
                >
                  {connector.id}
                  <Image
                    src={`/${connector.id}-icon.png`}
                    alt={connector.id}
                    width={30}
                    height={30}
                  />
                </ConnectWalletButton>
              ))}
            </Grid>
          </DialogContentText>
        </DialogContent>
        <DialogActions>
          <Button onClick={handleClose} color="inherit">
            Cancel
          </Button>
        </DialogActions>
      </Dialog>
    </StyledBox>
  );
}

export default function WalletBar({
  account,
}: {
  account: string | undefined;
}) {
  return account ? <WalletConnected address={account} /> : <ConnectWallet />;
}
----

==== Token Dropdown
As mentioned before, the dropdown component is in charge of displaying the tokens owned by the current connected wallet. In order to fetch these
tokens, the following transaction can be made. The only argument for the function is the contract address of the desired owner.

[source, typescript]
----
  const readTx = useMemo(() => {
    const tx = {
      address: STARKNET_HOMEPAGE_ERC721_ADDRESS,
      functionName: "getTokensByOwner",
      abi: starknetHomepageABI,
      args: [account || "0x0000000"],
    };
    return tx;
  }, [account]);

  const { data, isLoading } = useContractRead(readTx);
----

=== Multicall Contract Interaction
The following code is an example of a multi in order to approve a transaction for the transfer of the mint price and then the actual mint action.
It's important to highlight the use of `shortString`, this module from starknet.js encodes and splits a long string into an array of felt252's.  Which is the argument type the contract
on starknet is expecting.

`useContractWrite` is a Hook to perform a Starknet multicall, ofcourse it can be used with a single transaction instead of several.
[source,typescript]
----
  const calls = useMemo(() => {
    const splitNewImage: string[] = shortString.splitLongString(newImage);
    const splitNewLink: string[] = shortString.splitLongString(newLink);

    const tx2 = {
      contractAddress: STARKNET_HOMEPAGE_ERC721_ADDRESS,
      entrypoint: "mint",
      calldata: [
        startCell.col,
        startCell.row,
        width,
        height,
        splitNewImage,
        splitNewLink,
      ],
    };

    const price = selectedCells.length * 1000000000000000;

    const tx1 = {
      contractAddress: ERC_20_ADDRESS,
      entrypoint: "approve",
      calldata: [STARKNET_HOMEPAGE_ERC721_ADDRESS, `${price}`, "0"],
    };
    return [tx1, tx2];
  }, [startCell, newImage, newLink, width, height, selectedCells.length]);

  const { writeAsync: writeMulti } = useContractWrite({ calls });
----
Another important highlight is the calldata of the approve function for the ether transfer.

`calldata: [STARKNET_HOMEPAGE_ERC721_ADDRESS, '${price}', "0"],`

The amount argument is split into two because it's a u256, meaning it's made up of two seperate felt252 values.


Now that the multicall is setup, it's a matter of calling the actual function and signing the transaction with the connected wallet.
[source, typescript]
----
const handleMintClick = async (): Promise<void> => {
    setIsMintLoading(true);
    try {
        await writeMulti();
        setIsMintLoading(false);
        setState((prevState) => ({
        ...prevState,
        showPopup: false,
        selectedCells: [],
        mintPrice: undefined,
        }));
    } catch (error) {
        console.error("Error approving transaction:", error);
    }
};
----

Another great example of a conditional multicall setup is the Modal to edit the token's data.

image::starknet-homepage-edit.jpg[starknet-homepage-edit, width=640,height=480]

It might be the case that the user only wants to edit one of the properties of the token, not both. This leads to the requirement of a conditional multicall setup.
Note once again that the token id on the cairo contract is a `u256`, meaning it's made up of two felt252's.

[source, typescript]
----
  const calls = useMemo(() => {
    const txs = [];
    const splitNewImage: string[] = shortString.splitLongString(newImage);
    const splitNewLink: string[] = shortString.splitLongString(newLink);

    if (newImage !== "" && nft) {
      const tx1 = {
        contractAddress: STARKNET_HOMEPAGE_ERC721_ADDRESS,
        entrypoint: "setTokenImg",
        calldata: [nft.token_id, 0, splitNewImage],
      };
      txs.push(tx1);
    }

    if (newLink !== "" && nft) {
      const tx2 = {
        contractAddress: STARKNET_HOMEPAGE_ERC721_ADDRESS,
        entrypoint: "setTokenLink",
        calldata: [nft.token_id, 0, splitNewLink],
      };
      txs.push(tx2);
    }

    return txs;
  }, [nft, newImage, newLink]);
----

[NOTE]
====
The Book is a community-driven effort created for the community.

* If you've learned something, or not, please take a moment to provide feedback through https://a.sprig.com/WTRtdlh2VUlja09lfnNpZDo4MTQyYTlmMy03NzdkLTQ0NDEtOTBiZC01ZjAyNDU0ZDgxMzU=[this 3-question survey].
* If you discover any errors or have additional suggestions, don't hesitate to open an https://github.com/starknet-edu/starknetbook/issues[issue on our GitHub repository].
====

include::ROOT:partial$snippet_contributing_blurb.adoc[leveloffset=+1]
